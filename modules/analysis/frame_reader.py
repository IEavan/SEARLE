""" This module provides functionality for interacting with
the stored stock frames and formatting the information """

# Imports
import os
import time
import sector_helper

class Stock_Reader():
    """ Class for reading specific data from the stock frames
    generated by the webscraper """

    def __init__(self, data_path="./data/frames"):
        """ Read all the file names in the specified data directory """
        self.data_path = data_path
        self.files = os.listdir(data_path)
        self.files.sort()
        self.current_frame = self.files[-1]

    def get_attribute(self, ticker, attribute, frame):
        """ Access a simple attribute of a stock from a given frame """
        # format inputs
        attribute = attribute.lower().replace(' ', '_')
        ticker = ticker.upper().replace('.','')
        found = False

        with open(frame, 'r') as f:
            for line in f:
                _ticker, price, high, low, volume, last_close, abs_change, \
                        per_change, market_cap = line.strip().split(',')
                
                _ticker = _ticker.strip("'").replace('.','')
                
                if _ticker == ticker:
                    found = True

                    if attribute == "price":
                        return float(price)
                    if attribute == "high":
                        return float(high)
                    if attribute == "low":
                        return float(low)
                    if attribute == "volume":
                        return float(volume)
                    if attribute == "last_close" or attribute == "open":
                        return float(last_close)
                    if attribute == "abs_change" or attribute == "absolute_change":
                        return float(abs_change)
                    if attribute == "per_change" or attribute == "percentage_change":
                        return float(per_change)
                    if attribute == "market_cap":
                        return float(market_cap)
                    else:
                        raise ValueError("attribute " + attribute + "does not exist"
                                + "allowed values are {price, high, low, volume, last_close, abs_change, per_change}")
        if not found:
            return -1
    
    def get_risers(self, quantity, frame, rising=True):
        """ Return a dict of all the top or bottom stocks wrt percentage change """
        ftse_constituents = {}
        all_changes = []
        with open(frame, 'r') as f:
            f.readline() # Skip header
            for line in f:
                ticker, price, high, low, volume, last_close, \
                        abs_change, per_change, market_cap = line.strip().split(',')

                # Cast and format data from csv
                row = {}
                ticker = ticker.strip("'").replace('.','')
                row["price"] = float(price)
                row["high"] = float(high)
                row["low"] = float(low)
                row["last_close"] = float(last_close)
                row["abs_change"] = float(abs_change)
                row["per_change"] = float(per_change)
                row["market_cap"] = float(market_cap)

                ftse_constituents[ticker] = row
                all_changes.append(float(per_change))

        # Filter from ftse_constituents those stocks that don't have
        # a significant enough percentage change
        if rising:
            all_changes.sort(reverse=True)
            limit = all_changes[quantity - 1] # inclusive
            filtered_constituents = {}
            for stock in ftse_constituents:
                if ftse_constituents[stock]["per_change"] >= limit:
                    filtered_constituents[stock] = ftse_constituents[stock]
        else:
            all_changes.sort()
            limit = all_changes[quantity - 1] # inclusive
            filtered_constituents = {}
            for stock in ftse_constituents:
                if ftse_constituents[stock]["per_change"] <= limit:
                    filtered_constituents[stock] = ftse_constituents[stock]

        return filtered_constituents

    def get_risers_attribute(self, attribute, quantity, frame=None, rising=True):
        """ Extracts a list of attributes from the top or bottom <quantity> stocks """
        if frame is None:
            frame = os.path.join(self.data_path, self.current_frame)

        rising_stocks = self.get_risers(quantity, frame, rising=rising)
        attribute_list = []
        for stock in rising_stocks:
            attribute_list.append({"ticker": stock,
                                   "value": rising_stocks[stock][attribute]})

        return attribute_list

    def get_sector_attribute(self, sector_name, attribute, frame):
        """ Access a simple attribute about a whole sector """
        tickers = sector_helper.sector2tickers[sector_name.lower()]
        results = []
        for ticker in tickers:
            results.append((self.get_attribute(ticker, attribute, frame),
                            self.get_attribute(ticker, "market_cap",  frame)))

        total_market_cap = 0
        for result in results:
            total_market_cap += result[1]

        if attribute == "market_cap":
            return total_market_cap
        elif attribute == "volume":
            total_volume = 0
            for result in results:
                total_volume += result[0]
            return total_volume
        
        reduced_result = 0
        for result in results:
            reduced_result += result[0] * result[1]
        reduced_result /= total_market_cap

        return reduced_result

    def get_current_sector_attribute(self, sector_name, attribute):
        """ Get a simple attribute about a whole sector from the most recent time frame """
        frame = os.path.join(self.data_path, self.current_frame)
        return self.get_sector_attribute(sector_name, attribute, frame)

    def get_sector_range(self, sector_name, attribute, start_time, end_time=None):
        """ Get a list of values for an attribute in chronological order for a whole sector
        from the specified start time to the specified end time (not inclusive).
        If no end time is specified, the list goes up to the current time. """
        frame_times = [int(name[:-10]) for name in self.files]
        frame_times.sort()

        start_index = 0
        end_index = len(frame_times)

        for utime in frame_times:
            if start_time < utime:
                break
            else:
                start_index += 1

        if end_time is not None:
            frame_times.reverse()
            for utime in frame_times:
                if end_time > utime:
                    break
                else:
                    end_index -= 1

        valid_time_range = frame_times[start_index:end_index]
        frame_names = [self.unix_time_to_frame(utime, self.data_path)
                for utime in valid_time_range]

        return [self.get_sector_attribute(sector_name, attribute, frame) for frame in frame_names]


    def frame_to_unix_time(self, file_name):
        """ Convert a file name to a unix timestamp """
        file_name = os.path.basename(file_name)
        return int(file_name[:-10])

    def unix_time_to_frame(self, utime, base_path=None):
        """ Convert a unix timestamp to a filename """
        name = str(utime) + "-frame.csv"
        if base_path is not None:
            return os.path.join(base_path, name)
        else:
            return name

    def get_closest_frame(self, target_utime):
        """ Find the filename of the frame generated at a time closest to the target time """
        closest = None
        min_dist = -1
        for utime in [self.frame_to_unix_time(name) for name in self.files]:
            dist = abs(utime - target_utime)
            if dist < min_dist or min_dist == -1:
                min_dist = dist
                closest = self.unix_time_to_frame(utime)
        return os.path.join(self.data_path, closest)

    def get_current_attribute(self, ticker, attribute):
        """ Get a simple attribute of a stock from the most recent time frame """
        frame = os.path.join(self.data_path, self.current_frame)
        return self.get_attribute(ticker, attribute, frame)

    def get_attribute_range(self, ticker, attribute, start_time, end_time=None):
        """ Get a list of values for an attribute in chronological order
        from the specified start time to the specified end time (not inclusive).
        If no end time is specified, the list goes up to the current time. """
        frame_times = [int(name[:-10]) for name in self.files]
        frame_times.sort()

        start_index = 0
        end_index = len(frame_times)

        for utime in frame_times:
            if start_time < utime:
                break
            else:
                start_index += 1

        if end_time is not None:
            frame_times.reverse()
            for utime in frame_times:
                if end_time > utime:
                    break
                else:
                    end_index -= 1

        valid_time_range = frame_times[start_index:end_index]
        frame_names = [self.unix_time_to_frame(utime, self.data_path)
                for utime in valid_time_range]

        return [self.get_attribute(ticker, attribute, frame) for frame in frame_names]

if __name__ == "__main__":
    reader = Stock_Reader()
    print(reader.get_risers_attribute("per_change", 3, rising=False))
